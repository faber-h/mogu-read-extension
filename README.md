# MoguRead

<div align="center">
  <img width="300" height="300" alt="moguRead" src="" />

  <p>
    <strong>MoguRead</strong>는 사용자가 중요하지 않은 문장들을 제거하고<br />
    핵심에만 집중할 수 있도록 도와주는 몰입형 독서 크롬 확장 프로그램입니다.<br />
    귀여운 마스코트 <strong>모구(Mogu)</strong>가 독서에 함께하며, 읽기를 보다 즐겁게 만들어줍니다.
  </p>
</div>
<br>

# 📖 목차

- [💥 개발 배경](#-개발-배경)
- [🔍 기능 소개](#-기능-소개)
- [🛠️ 기술 스택](#-기술-스택)
- [⚙️ 개발 과정](#-개발-과정)
- [💭 프로젝트 소감](#-프로젝트-소감)

<br>

# 💥 개발 배경

이 프로젝트는 하나의 이미지에서 출발했습니다.

> **"텍스트를 따라가며 문장을 하나씩 먹어치우는 작은 캐릭터."**

마치 팩맨처럼 문장을 먹으며 움직이는 캐릭터를 상상하면서  
자연스럽게 **"읽고 싶은 문장만 남기고 나머지는 없앨 수 없을까?"**라는 질문으로 이어졌습니다.

웹에서 글을 읽다 보면,  
진짜 중요한 한 줄을 찾기 위해 수많은 부연 설명과 예시, 주석을 지나쳐야 하는 일이 많습니다.  
React 공식 문서에서 예를 들자면

> `export default` 접두사는 표준 JavaScript 구문입니다(React에만 해당되지 않습니다).

괄호 안의 문장이 지금 내게 정말 필요한 정보일까요?

이처럼 핵심이 아닌 문장, 몰입을 방해하는 부가 설명들을  
직접 정리하고, **읽고 싶은 부분만 남겨둘 수 있다면**  
읽기는 더 깔끔하고, 집중력 있는 경험이 될 수 있을 거라고 생각했습니다.

MoguRead는 이런 상상에서 출발한 프로젝트입니다.  
**읽는 행위에 집중하고, 몰입을 방해하는 요소들을 '먹어 치우는' 경험을 제공합니다.**  
작지만 귀여운 마스코트 <strong>모구(Mogu)</strong>가 독서에 함께하며, 읽기를 놀이처럼 만들어줍니다.

<br>

# 🔍 기능 소개

| 이미지 | 설명 |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![정리모드]()     | **정리 모드**<br> - 집중을 방해하는 문장을 제거하여 핵심 내용에 몰입할 수 있도록 도와주는 기능입니다.<br> - 정리하고 싶은 문장을 드래그하면 ‘정리 대상’으로 등록됩니다.<br> - 선택된 문장은 클릭 시 하이라이트 되어 어떤 문장이 정리될지 확인할 수 있습니다.<br> - “정리 시작” 버튼을 누르면, 선택된 문장들이 페이지에서 제거됩니다.<br> - 정리된 문장을 클릭하면 해당 문장이 있었던 위치에 인디케이터와 안내 문구가 표시되어 위치를 확인할 수 있습니다.                              |
| ![몰입읽기모드]() | **몰입 읽기 모드**<br> - 일정 시간 내에 읽지 않으면 문장이 점차 사라지는 몰입 독서 기능입니다.<br> - 문장을 선택한 후, “읽기 시작” 버튼을 누르면 선택된 속도에 따라 모드가 시작됩니다.<br> - 읽기 속도는 시작 전 미리 조절할 수 있으며, 사용자의 집중력에 맞게 설정 가능합니다.<br> - 마스코트 <strong>모구(Mogu)</strong>가 문장을 따라다니며 ‘먹어치우는’ 연출을 통해 읽기에 몰입하도록 유도합니다.<br> - “일시정지”, “되돌리기”, “재시작” 버튼으로 읽기 진행을 조절할 수 있습니다. |
| ![대시보드]()     | **대시보드**<br> - 정리한 문장과 몰입 읽기 기록을 날짜별로 시각적으로 확인할 수 있는 기능입니다.<br> - 연도, 월을 기준으로 필터링하여 조회할 수 있습니다.<br> - 기록은 필요에 따라 개별 삭제할 수 있습니다. |

<br>

# 🛠️ 기술 스택

<div>
  <img src="https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&logo=JavaScript&logoColor=000" />
  <img src="https://img.shields.io/badge/React-61DAFB?style=for-the-badge&logo=React&logoColor=white" />
  <img src="https://img.shields.io/badge/React Router-CA4245?style=for-the-badge&logo=react&logoColor=white" />
  <img src="https://img.shields.io/badge/Zustand-553830?style=for-the-badge" />
  <img src="https://img.shields.io/badge/Tailwind CSS-06B6D4?style=for-the-badge&logo=tailwindcss&logoColor=white" />
  <img src="https://img.shields.io/badge/Chrome Extension-4285F4?style=for-the-badge&logo=Google Chrome&logoColor=white" />
  <img src="https://img.shields.io/badge/Vite-646CFF?style=for-the-badge&logo=Vite&logoColor=white" />
</div>

<br>

# ⚙️ 개발 과정

## 확장 프로그램 구조

크롬 확장 프로그램은 각 영역이 명확히 역할을 분담하고, 메시지를 주고받는 구조로 설계되어 있습니다.
이러한 구성 요소들은 manifest.json 파일을 통해 선언되고 유기적으로 연결되어, 확장 프로그램이 브라우저 환경에서 안정적으로 동작할 수 있도록 합니다.

MoguRead에서 가장 핵심적인 영역은 Content Script입니다.
이 스크립트는 실제 웹페이지 내부에 삽입되어, 사용자가 보고 있는 DOM 요소에 직접 접근하고 이를 조작할 수 있습니다.
예를 들어, 마스코트 모구(Mogu)가 등장해 문장을 ‘먹어치우는’ 시각적 상호작용이나,
사용자가 선택한 문장을 하이라이팅하거나 제거하는 등의 모든 몰입형 기능들이 이 영역을 통해 구현됩니다.

### 주요 구성 요소 및 역할

**1. Manifest(manifest.json)**

manifest.json은 확장 프로그램의 진입점이자 설정 파일입니다.
모든 기능은 이 파일을 기준으로 정의되고 연결됩니다.
- 리소스 정의: 어떤 스크립트와 HTML, 이미지 등을 사용할지 선언합니다.
- 권한 설정: Content Script가 삽입될 웹사이트나 storage, sidePanel 등의 API 사용 권한을 명시합니다.
- 컴포넌트 연결: Service Worker, Content Script, Side Panel, Options 페이지 등의 각 구성 요소를 유기적으로 연결합니다.

| 설정 항목 | 설명|
| ----------------- | --------------------------------------------------------------------------------------- |
| background.service_worker | 사이드 패널의 이벤트 처리나 페이지 간 이동을 감지하고, 각 영역의 제어 역할을 합니다. |
| content_scripts | 사용자가 방문하는 웹페이지에 삽입되어, 마스코트 모구(Mogu)를 띄우고 텍스트를 정리하거나 하이라이팅하는 등 DOM 조작을 수행합니다. |
| side_panel.default_path | 사용자가 정리된 문장들을 확인하거나 몰입 읽기 모드를 시작할 수 있는 UI 패널의 진입점입니다. |
| web_accessible_resources | Content Script에서 모구 이미지 등의 리소스를 직접 접근하고 사용할 수 있도록 허용합니다. |
| host_permissions, permissions | 사이트 접근(activeTab), 저장(storage), 사이드패널 제어(sidePanel) 등 필요한 권한을 선언합니다. |


**2. Content Script**

Content Script는 확장 프로그램에서 사용자가 현재 보고 있는 웹페이지 내부에 직접 삽입되는 JavaScript 스크립트입니다.
MoguRead의 핵심 기능 대부분은 이 영역에서 구현되며, 실제 페이지의 DOM에 접근하고 이를 조작할 수 있는 유일한 실행 영역입니다.

| 주요 역할 | 설명|
| ----------------- | --------------------------------------------------------------------------------------- |
| DOM 조작 | 사용자가 선택한 문장을 제거하거나, 몰입 읽기 모드에서 일정 시간이 지나면 단어를 투명하게 처리하는 등 페이지 내용을 직접 수정합니다. |
| 마스코트 UI 삽입 | 마스코트 **모구(Mogu)**를 DOM에 삽입하고, 위치 제어 및 애니메이션 처리를 통해 시각적 피드백과 몰입감을 제공합니다. |
| 메시지 수신 및 반응 | Side Panel에서 전달된 메시지(예: “읽기 시작”, “정리 시작”)를 수신하여, 그에 맞는 동작을 수행합니다. |

**3. Service Worker**

Service Worker는 확장 프로그램의 백그라운드 중앙 제어 허브 역할을 수행합니다.
탭 상태를 감지하여 Content Script를 자동으로 주입하고, 사용자의 액션(예: 사이드패널 열기)과 스크립트 실행 간의 연결을 관리합니다.

| 주요 기능 | 설명|
| ----------------- | --------------------------------------------------------------------------------------- |
| Side Panel 설정 | 사용자가 확장 아이콘을 클릭했을 때 Side Panel이 자동으로 열리도록 설정합니다. |
| 탭 활성화 감지 | 사용자가 탭을 전환할 때, 해당 탭에 Content Script가 삽입되었는지 확인하고, 없다면 삽입합니다. |
| 탭 업데이트 감지 | 사용자가 페이지를 새로고침하거나 주소가 변경했을 때, DOM 로딩이 완료되면 Content Script를 자동으로 삽입합니다. |
| 예외 처리 | chrome:// 또는 chrome-extension://와 같은 내부 페이지에서는 Content Script를 삽입하지 않도록 필터링합니다. |

**4. Side Panel**

Side Panel은 기능을 제어할 수 있는 UI 중심의 상호작용 영역입니다.
정리 모드, 몰입 읽기 모드 등 주요 기능을 실행하는 출발점 역할을 하며, 이때 발생한 명령은 Content Script로 직접 전달되어 웹페이지에서 실행됩니다.

| 주요 역할 | 설명|
| ----------------- | --------------------------------------------------------------------------------------- |
| 기능 실행의 출발점 | “정리 시작”, “읽기 시작” 등 사용자의 액션을 트리거합니다. 해당 메시지는 Content Script로 전송됩니다. |
| 사용자 입력 수집 | 읽기 속도 설정, 정리 대상 문장 확인, 기록 선택 등 다양한 상호작용을 처리합니다. |
| 뷰 전환 및 상태 반영 | 몰입 읽기 모드, 정리 모드의 전환이 가능하며, 현재 상태를 시각적으로 표시합니다. |

## 몰입 읽기 모드

몰입 읽기 모드는 사용자가 정리한 문장을 마스코트 ‘모구(Mogu)’가 따라가며 읽는 애니메이션 기능입니다.
텍스트를 따라가는 시각적 흐름과 부드러운 스크롤 처리를 통해 사용자가 글에 더 집중할 수 있도록 설계되었습니다.

핵심 구성 요소
| 구성 요소 | 설명|
| ----------------- | --------------------------------------------------------------------------------------- |
| Mogu 이미지 | 단어를 따라 움직이는 마스코트 캐릭터를 DOM에 추가합니다. |
| 문장 포맷팅 | 읽기 대상 단어는 .mogu-word 클래스를 부여해 구분합니다. |
| 애니메이션 제어 | 실제 페이지에서 DOM을 조작하고, 모구 애니메이션을 수행합니다. |
| 메시지 전송 | 진행 상황을 사이드 패널로 전송하여 UI와 동기화합니다. |

작동 흐름 요약
1. 페이지에서 읽기 대상 단어를 감싸고 애니메이션을 위한 클래스를 부여
2. 모구를 페이지에 삽입
3. 모구 애니메이션으로 읽기 시작
4. 모구 이동 애니메이션에 맞춰 투명도 조정 클래스 추가
5. 한 줄이 끝나면 다음 줄로 자연스럽게 이동하며, 화면도 중앙에 맞춰 스크롤

### Mogu 이동 처리 방식

모구는 각 단어의 시작 위치에서 끝 위치까지 좌우로 이동합니다.
단어마다 글자 수 및 줄바꿈 여부를 고려해 이동 속도 및 위치 보정을 수행합니다.

- 모구 이동 애니메이션
```
mogu.style.transition = `left ${animationDuration}ms ease`;
mogu.style.left = `${endX}px`;
```

- 스크롤 보정 처리
문장이 화면 중앙에 보이도록 자동 스크롤합니다.
```
word.scrollIntoView({ behavior: "smooth", block: "center" });
```

### 고려 사항

#### **읽기 속도 기준 (WPM 기반)**

- 속도 설정 값:
- 느림(SLOW): 120 WPM → 약 500ms/단어
- 보통(NORMAL): 200 WPM → 약 300ms/단어
- 빠름(FAST): 300 WPM → 약 200ms/단어

> 참고 논문: 대한안과학회지 J Korean Ophthalmol Soc 2016;57(4):642-649
> “한국어 읽기 속도 측정 애플리케이션의 유효성 및 정상인의 읽기 속도에 대한 사전 연구”
> 평균 읽기 속도: 202.3 ± 88.4 WPM (20~30대 성인 기준)

#### **문장 길이에 따른 속도 보정**

짧은 단어는 빠르게, 긴 단어는 천천히 읽히도록 보정이 적용됩니다.
기본 속도는 WPM(words per minute) 기준으로 설정되며, 4자 초과 시 글자당 15ms를 추가합니다.

긴 단어가 시각적으로 더 많은 인지 시간을 요구한다는 점은 Spritz(RSVP 기반 속독 기술)에서도 검증된 방식입니다.
MoguRead는 Spritz와 유사하게 글자 수에 따라 읽기 시간을 보정하여 가독성과 몰입 흐름을 함께 고려했습니다.

>“Words of 4-to-7 characters spritz through a display the fastest. Others have algorithmic slowing applied…”
>— Spritz Inc.

#### **시작 위치 보정**

모구 애니메이션 시작 좌표가 어긋날 수 있습니다.
이를 보완하기 위해 첫 글자의 실제 픽셀 너비를 측정한 뒤, 시작 지점을 보정합니다

#### **줄바꿈 처리**

이전 문장과 현재 문장의 getBoundingClientRect().top 값을 비교하여 줄바꿈 여부를 판단합니다.
줄이 바뀌었을 경우, 다음 문장의 시작 위치로 모구를 즉시 이동시키고 이후 이동 애니메이션을 다시 실행합니다.

## 웹페이지 내 정리하고 싶은 문장 제거 기능 (정리 기능)

정리 기능은 사용자가 선택한 문장들을 페이지에서 제거함으로써, 핵심 내용에만 집중할 수 있도록 도와주는 기능입니다. 마스코트 모구(Mogu)가 선택된 문장을 ‘먹는’ 애니메이션과 함께 제거하여 몰입감 있는 상호작용을 제공합니다.<br>

핵심 구성 요소
| 구성 요소 | 설명|
| ----------------- | --------------------------------------------------------------------------------------- |
| 사용자 선택 감지 | 사용자가 웹페이지에서 드래그로 문장을 선택하면 자동으로 문장 정보가 추출됩니다. |
| Side Panel UI | 사용자가 선택한 문장을 시각적으로 확인하고 정리 시작 버튼을 눌러 실행하는 출발점입니다. |
| Content Script | 실제 페이지에서 DOM을 조작하고, 모구 애니메이션 및 문장 제거를 수행합니다. |
| 메시지 전송 | 사이드패널과 콘텐츠 스크립트 간 통신을 통해 메시지을 주고받는 채널 역할을 합니다. |

작동 흐름 요약
1. 사용자가 웹페이지에서 문장을 드래그로 선택
2. Side Panel에 선택된 문장이 표시
3. 사용자가 정리 시작 버튼 클릭
4. Content Script로 정리 메시지 전달
5. Content Script가 모구 애니메이션을 실행하고 문장을 제거
6. 제거 완료 후 정리 완료 메시지 전송
7. 제거된 문장은 chrome.storage.local에 저장

### 정리하고 싶은 문장 선택 감지

사용자가 웹페이지 내에서 정리하고 싶은 문장을 마우스로 드래그해 선택하면, Content Script에서 해당 이벤트를 감지하여 다음과 같은 작업을 수행합니다.

1. 드래그 선택 감지
- mouseup 이벤트를 통해 사용자의 마우스 드래그 종료 시점을 감지합니다.
- 선택된 텍스트가 없거나, 중복된 선택인 경우에는 무시됩니다.

2. 선택된 문장 포장 및 식별 정보 생성
- 선택된 문장은 고유하게 식별할 수 있도록 data-word-id가 부여된 span 태그로 감싸집니다.
- 식별 정보가 함께 수집되며 이 과정을 통해 이후 정리 및 복원에 필요한 정밀한 DOM 위치 정보가 확보됩니다.
  - 선택된 실제 텍스트 (text)
  - 선택된 위치를 나타내는 CSS Selector (selector)
  - 시작/끝 offset (startOffset, endOffset)
  - 고유 식별자 (id)
  - 현재 페이지 URL

3. 메시지 전송
- 포장된 문장 데이터는 메시지를 통해 Side Panel로 전송됩니다.
- Side Panel은 해당 문장을 선택된 문장 UI에 표시하고, 사용자의 액션을 기다립니다.

### "정리 시작" 버튼 클릭

사용자가 “정리 시작” 버튼을 누르면, 메시지를 통해 Content Script로 명령이 전송됩니다.
이때 전달되는 메시지에는 제거할 문장을 식별하는 고유 식별자(id) 목록이 포함됩니다.

이 구조는 사용자 인터페이스와 페이지 조작 로직을 분리하여 유지보수성과 확장성을 확보합니다.

### 콘텐츠 스크립트에서 모구 등장 및 정리 애니메이션 실행

Content Script는 정리 작업의 핵심 역할을 수행합니다.  
정리 시작 메시지를 수신한 후, 다음과 같은 단계로 작업이 진행됩니다.

1. 모구(Mogu) 초기화 및 위치 설정
- 기존에 삽입된 모구가 있다면 제거하고 새로 배치하여 중복 삽입을 방지합니다.
- 모구는 제거 대상 문장으로 직접 이동하면서, ‘먹는’ 동작을 시각적으로 표현합니다.

2. 문장별 애니메이션 실행
- 문장 위치 계산: data-word-id 속성으로 해당 문장을 식별하고, getBoundingClientRect()로 좌표를 계산합니다.
- 모구 이동 애니메이션: 좌측에서 우측으로 transition을 적용해 모구가 문장을 ‘먹는’ 듯한 이동을 실행합니다.
- 문장 제거 처리: 애니메이션 후, 해당 문장의 opacity를 0으로 만든 뒤, 실제로 remove()로 DOM에서 제거합니다.

각 문장은 하나씩 천천히 순차적으로 제거되어 사용자가 시각적 효과를 명확히 인지할 수 있도록 설계되었습니다.

### 고려 사항

#### **구현 방식**

| 접근 방식 | 장점 | 단점 |
| ----------------- | -------------------------------------- |  -------------------------------------- |
| display: none 처리 | DOM 유지 가능, 간단한 숨김 처리 가능 | 제거 효과가 시각적으로 약함 |
| opacity 및 remove 조합 | 시각적 효과와 실제 제거를 모두 만족 | 구현 복잡도가 상대적으로 높음 |

MoguRead에서는 시각적 몰입감과 기능 안정성을 모두 확보하기 위해 opacity + remove 방식으로 설계되었습니다.

```
// 문장 요소의 투명도 조절
wordElement.style.transition = `opacity 600ms ease`;
wordElement.style.opacity = "0";

// 애니메이션 종료 후 실제 제거
await delay(650);
wordElement.remove();
```

이 방식은 단순히 display: none만 사용하는 경우와 달리, 애니메이션을 통해 사용자가 제거 과정을 명확히 인식할 수 있게 하며, 실제 DOM에서도 제거되므로 이후 불필요한 노드가 남지 않아 UI 상 충돌을 최소화할 수 있습니다.

#### **뷰포트 밖 문장 처리**

문장이 화면에 보이지 않는 위치에 있는 경우, 모구의 애니메이션 이동이 갑작스럽게 튀는 듯한 부자연스러운 시각 효과가 발생할 수 있습니다. 이를 방지하기 위해, 정리 대상 문장이 현재 시야 밖에 있을 경우 자동으로 해당 문장을 화면 중앙 근처로 스크롤하여 이동하도록 처리했습니다.

```
wordElement.scrollIntoView({
  behavior: "instant",  // 즉시 이동하여 깜빡임 최소화
  block: "center",      // 수직 중앙에 위치시켜 시각적 일관성 확보
});
```
이 처리는 모구의 이동 경로가 항상 화면 내에서 자연스럽게 유지되도록 보장하며, 사용자 입장에서 문장이 어떻게 제거되고 있는지를 명확히 인식할 수 있게 도와줍니다.

### 정리 완료 후의 상태 저장 및 히스토리 유지

문장의 제거가 모두 완료되면, Content Script는 마지막으로 정리 완료 메시지를 사이드 패널에 전송합니다.
이 메시지는 정리 애니메이션이 모두 끝났으며, 지금이 사용자 기록을 저장할 시점임을 의미합니다.

정리된 문장의 기록 보존

정리된 문장은 단순히 일시적으로 제거되는 것이 아니라,
- 추후 같은 웹페이지에 재접속했을 때 복원 여부를 판단하거나,
- 정리 위치를 시각적으로 다시 안내하거나,
- 사용자 기록(히스토리)으로 남겨두기 위해
기록이 필요합니다.

이를 위해 다음과 같은 정보가 **chrome.storage.local**에 저장됩니다.
| 필드명 | 설명|
| ----------------- | --------------------------------------------------------------------------------------- |
| text | 실제 정리된 문장의 텍스트 |
| id | 문장마다 부여된 고유 식별자 (data-word-id 기반)|
|selector|문장이 속해 있던 상위 DOM 요소의 고유 CSS 선택자|
|startOffset / endOffset|해당 문장의 위치를 DOM 내에서 재현할 수 있는 상대 위치|
|url|해당 문장이 존재했던 페이지의 URL|
|savedAt|정리 작업이 수행된 시각 (timestamp)|

이 저장 구조는 추후 문장 복원이나 히스토리 기능에 활용될 수 있어,
사용자 경험의 일관성을 높이는 데 기여합니다.

## 정리된 문장의 위치 시각화 (삭제 위치 표시 기능)

사용자는 이전에 정리했던 문장이 어디에 있었는지 궁금할 수 있습니다.
MoguRead는 사이드 패널에서 정리 기록을 클릭하면, 해당 문장이 원래 있었던 위치를 페이지 내에서 시각적으로 표시하는 기능을 제공합니다.

이 기능은 단순한 정보 조회가 아니라, 실제로 문장이 있던 위치를 찾아서 **인디케이터(표시자)**를 삽입하고, 해당 위치로 부드럽게 스크롤시켜 사용자에게 정확한 위치를 안내합니다.

작동 흐름 요약
1. chrome.storage.local에서 정리된 문장 불러오기
2. 사용자가 사이드패널에서 정리된 문장 클릭
3. 문장이 속했던 상위 DOM 요소와 상대 오프셋을 기준으로 위치 계산
4. 인디케이터(.mogu-position-indicator)를 해당 위치에 삽입
5. 화면 중앙으로 스크롤하고, 3초 후 인디케이터 자동 제거

### 위치 계산

문장이 DOM에서 삭제되었기 때문에 단순한 텍스트 탐색으로는 정확한 위치를 알 수 없습니다.
이를 보완하기 위해 selector, startOffset, text, savedAt을 바탕으로 동일한 요소 내 복수 문장이 삭제되었을 경우까지 고려한 오프셋 보정 알고리즘을 수행합니다.

1. 대상 요소 찾기
- 저장된 selector 값을 사용해, 삭제된 문장이 속해 있던 상위 DOM 요소를 찾습니다.

2. 같은 요소 내의 모든 정리 기록 불러오기
- 같은 selector를 갖는 모든 정리된 문장들을 수집하여,
- 같은 요소 내 여러 문장이 삭제된 경우에도 정확한 상대 위치를 판단할 수 있도록 준비합니다.

3. 현재 DOM에 있는지 판별 (복원 vs 삭제)
- 요소 내 텍스트를 확인하여 문장이 여전히 존재하면 복원 상태,
존재하지 않으면 삭제 상태로 분류합니다.

4. 삭제된 경우: 오프셋 위치 재계산
- 같은 요소 내 앞서 삭제된 문장들이 영향을 준 오프셋만큼 보정합니다.
```
const currentPosition = Math.max(0, targetItem.startOffset - offsetAdjustment);
```
- 여기서 offsetAdjustment는 이전에 삭제된 문장들의 길이를 누적한 값입니다.

5. 최종 위치 계산
- 보정된 오프셋을 기준으로 텍스트 노드를 순회하면서 정확한 노드와 위치를 찾아냅니다.
```
const walker = document.createTreeWalker(targetElement, NodeFilter.SHOW_TEXT);
```
- 텍스트 노드를 순차적으로 탐색하면서, 삭제된 문장의 위치에 가장 근접한 지점을 계산합니다.
- 이후 보정된 offset에 도달하면, 그 위치에 인디케이터를 삽입할 수 있습니다.

## chrome.storage.local 사용 이유

MoguRead는 도메인 제약 없이, 브라우저 종료 후에도 데이터가 유지되야 하기 때문에
Chrome 확장 전용 비동기 저장소인 chrome.storage.local을 선택했습니다.

### 상세 선택 이유

1. 페이지와 무관하게 안전하게 데이터 보존 가능
- localStorage와 달리 도메인 종속이 없고, 확장 프로그램 자체의 스코프에서 데이터가 저장됩니다.
- 즉, 사용자가 어떤 웹사이트에서 선택을 했든, 전혀 상관없이 데이터를 안전하게 보존할 수 있습니다.
- 이는 여러 도메인에서 일관된 방식으로 문장 기록을 관리해야 하는 MoguRead에 적합합니다.

2. 브라우저 종료 후에도 데이터 유지
- chrome.storage.local에 저장된 데이터는 브라우저를 종료하거나 재부팅해도 유지됩니다.
- MoguRead는 사용자가 이전에 정리한 문장을 다시 기억하고 재활용하므로, 세션이 끝나도 지속적으로 접근 가능한 저장소가 필요합니다.

3. 용량 여유가 충분함
- chrome.storage.local은 기본적으로 5MB 용량 제한을 제공하며, 대부분의 정리 데이터에는 충분합니다.
- 문장 단위의 텍스트와 선택자/offset 정보는 용량이 작기 때문에, 수백~수천 개의 문장도 무리 없이 저장할 수 있습니다.

4. 비동기 API 제공으로 확장성과 안정성 확보
- chrome.storage.local은 비동기 방식으로 작동하여, 성능 저하 없이 데이터 저장/조회가 가능합니다.
- 특히 정리 기능이 애니메이션 등 비동기 흐름과 함께 작동하기 때문에, UI가 멈추지 않고 부드럽게 동작하는 데 유리합니다.

5. 자동 백업/동기화 고려 시 유연성 확보
- 향후 chrome.storage.sync로의 확장도 고려 가능하며,
- local에 저장된 구조는 Firebase 등 외부 저장소와 연동할 때도 형식 호환성과 분리 설계에 유리합니다.

### 다른 저장 방식과의 비교

| 저장 방식 | 장점 | 단점 |
| ----------------- | -------------------------------------- |  -------------------------------------- |
| localStorage | 사용하기 간단, 동기 방식 | 도메인 종속, 확장 프로그램 외부에 노출됨 |
| sessionStorage | 세션 기반 임시 저장 | 브라우저 닫으면 사라짐 |
| IndexedDB | 대용량, 정교한 구조화 가능 | 구현 복잡도 높음, 오버스펙 |
| chrome.storage.local | 적절한 성능, 확장 프로그램 전용 스코프, 비동기 | 단일 사용자 기준, 오직 확장 전용 |

MoguRead는
- 사이트와 무관하게 작동하고,
- 브라우저가 꺼져도 기록을 유지해야 하며,
- UI가 끊기지 않도록 부드럽게 동작해야 합니다.

이 조건을 충족하는 저장소인 chrome.storage.local를 데이터 저장소로 채택했습니다.

# 💭 프로젝트 소감

이번 프로젝트는 단순히 기능을 구현하는 것을 넘어서, 사용자 경험(UX)을 중심에 두고 설계하고 개선하는 과정에 집중한 경험이었습니다.
정리된 문장의 삭제 위치를 시각적으로 다시 안내하는 기능, 문장 길이에 따른 읽기 속도 보정,
시작 좌표의 위치 보정, 줄바꿈 감지 후 부드러운 스크롤 처리 등
세밀한 동작 하나하나가 사용자에게 어떤 감각으로 전달될지를 끊임없이 고민하며 구현했습니다.

처음엔 단순한 아이디어였지만, 실제로 구현해보니
시각적 흐름, 위치 계산, 애니메이션 타이밍 등 고려해야 할 것이 많았고,
완성도를 높이기 위해 많은 시행착오와 고민을 반복했던 프로젝트였습니다.

이번 작업을 통해 기능 구현을 넘어서 사용자 관점에서 사고하고,
기술적 세부사항까지 주도적으로 설계하는 개발 경험을 쌓을 수 있었습니다.
앞으로도 한 걸음씩 실력을 확장해 나가며, 점점 더 의미 있는 제품을 만들 수 있는 개발자로 성장하고 싶습니다.
